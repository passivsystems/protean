var tipuesearch={"pages":[{"title":"Tutorial \/ Overview","text":" Overview A progressive tutorial This is a progressive tutorial designed to gradually demonstrate the main features of Protean. It is aimed to be fun so each part will follow on from the previous, the aim being to build an online text adventure game driven by a RESTful API for exploring it, and building it. ","tags":"","loc":"tutorial.html#tut-overview"},{"title":"Tutorial \/ Part 1 - encoding (basics)","text":" Part 1 - Encoding The basics Protean encodes RESTful API's using a codex. A codex is pretty much just some Clojure code in a file with an extension cod.edn. The codex is the single point of truth. Nothing leaks from Protean into your source code... no annotations, no pollution of any kind. { :includes [&quot;defaults.edn&quot;] :title &quot;Tutorial 1&quot; &quot;tutorial-1&quot; {&quot;play&quot; {:get {}}} } Explanation This is just about the simplest codex. Out of this we get : an endpoint tutorial-1\/play a get method a nice title for the api docs some free preferences for response status codes in 'defaults.edn' Run it We will start with creating the apidocs for the service defined in this tutorial. copy tutorial-1.cod.edn from public\/tutorial to your codex directory enter lein run visit -f tutorial-1.cod.edn -b '{&quot;locs&quot;:[&quot;tutorial-1&quot;], &quot;commands&quot;:[&quot;doc&quot;], &quot;directory&quot;:&quot;silk_templates\/data\/protean-api&quot;}' open the index.html file created in silk_templates\/site ","tags":"","loc":"tutorial.html#tut-part-1"},{"title":"Tutorial \/ Part 2 - encoding (docs\/types)","text":" Part 2 - Encoding Documentation and types { :includes [&quot;defaults.edn&quot;] :title &quot;Tutorial 2&quot; &quot;tutorial-2&quot; { &quot;play\/${stateId}&quot; { :get { :doc &quot;A single player REST adventure world&quot; :description &quot;A simple text adventure world for one player. Sample usage may be something like \/tutorial-2\/play\/cave, indicating the player is in a cave.&quot; :vars { &quot;stateId&quot; {:type :Int :doc &quot;ID for the state of the game&quot;} } :rsp { :404 {:doc &quot;Not Found&quot;} } } } } } Explanation This adds a few things to the previous codex definition : a path parameter stateId a simple doc string a multiline description for providing semantic information some variable information defining the type of the path parameter a 404 (Not Found) error response Run it Create your apidocs again. copy tutorial-2.cod.edn from public\/tutorial to your codex directory enter lein run visit -f tutorial-2.cod.edn -b '{&quot;locs&quot;:[&quot;tutorial-2&quot;], &quot;commands&quot;:[&quot;doc&quot;], &quot;directory&quot;:&quot;silk_templates\/data\/protean-api&quot;}' open the index.html file created in silk_templates\/site ","tags":"","loc":"tutorial.html#tut-part-2"},{"title":"Tutorial \/ Part 3 - encoding (response bodies)","text":" Part 3 - Encoding Response bodies { :includes [&quot;defaults.edn&quot;] :title &quot;Tutorial 3&quot; &quot;tutorial-3&quot; { &quot;play\/${stateId}&quot; { :get { :doc &quot;A single player REST adventure world&quot; :description &quot;A simple text adventure world for one player. Sample usage may be something like \/tutorial-3\/play\/cave, indicating the player is in a cave.&quot; :vars { &quot;stateId&quot; {:type :Int :doc &quot;ID for the state of the game&quot;} } :rsp { :200 { :doc &quot;OK&quot; :body-example &quot;test-data\/content\/tutorial\/tutorial-3\/200-ref.json&quot; } :503 { :doc &quot;Service Unavailable&quot; :headers {&quot;Content-Type&quot; &quot;application\/problem+json&quot; &quot;Content-Language&quot; &quot;en&quot;} :body-example &quot;test-data\/content\/tutorial\/tutorial-3\/lazy-server-gremlins.json&quot; } } } } } } Explanation We now add some new concepts to the previous codex definition : a response body for a 200 (OK) response swap the 404 response for a 503 and add a response header Where it is possible for a response to have a body it is good practice to include a reference example in the codex. It is entirely possible that an error response, like the 503 defined in this example could have a completely different body Run it Create your apidocs again. copy tutorial-3.cod.edn from public\/tutorial to your codex directory enter lein run visit -f tutorial-3.cod.edn -b '{&quot;locs&quot;:[&quot;tutorial-3&quot;], &quot;commands&quot;:[&quot;doc&quot;], &quot;directory&quot;:&quot;silk_templates\/data\/protean-api&quot;}' open the index.html file created in silk_templates\/site ","tags":"","loc":"tutorial.html#tut-part-3"},{"title":"Tutorial \/ Part 4 - simulation (basics)","text":" Part 4 - Simulation The basics Explanation You do not need to do anything to get a basic simulation for free. It has always been available. Run it Run the simulation, using the tutorial-3 codex which you have already copied into your codex directory. run protean-server run protean services run protean service-usage -n tutorial-3 select the curl statement generated as output of the previous step and execute it You should see output like : { &quot;description&quot;: &quot;You are in a cave, it is very dark&quot; } ","tags":"","loc":"tutorial.html#tut-part-4"},{"title":"Tutorial \/ Part 5 - simulation (errors)","text":" Part 5 - Simulation Simulating errors To override the default simulation behaviour (which returns success responses) create a sim extension file. We will re-use the codex from tutorial-3 (renaming it to tutorial-5) and place the new sim extension in the same location. The renamed codex is listed below. { :includes [&quot;defaults.edn&quot;] :title &quot;Tutorial 5&quot; &quot;tutorial-5&quot; { &quot;play\/${stateId}&quot; { :get { :doc &quot;A single player REST adventure world&quot; :description &quot;A simple text adventure world for one player. Sample usage may be something like \/tutorial-5\/play\/cave, indicating the player is in a cave.&quot; :vars { &quot;stateId&quot; {:type :Int :doc &quot;ID for the state of the game&quot;} } :rsp { :200 { :doc &quot;OK&quot; :body-example &quot;test-data\/content\/tutorial\/tutorial-3\/200-ref.json&quot; } :503 { :doc &quot;Service Unavailable&quot; :headers {&quot;Content-Type&quot; &quot;application\/problem+json&quot; &quot;Content-Language&quot; &quot;en&quot;} :body-example &quot;test-data\/content\/tutorial\/tutorial-3\/lazy-server-gremlins.json&quot; } } } } } } Now we list our first sim extension. (refer 'protean.core.transformation.sim) { &quot;tutorial-5&quot; { &quot;play\/${stateId}&quot; { :get [#(error)] } } } Explanation In our first sim extension example we override the get method to return a random error status code, which in this case must be the 503 we defined in the codex. As you can see the general structure of the sim matches that of the codex. Run it Run the simulation. copy tutorial-5.cod.edn and tutorial-5.sim.edn from public\/tutorial to your codex directory run protean-server run protean services run protean service-usage -n tutorial-5 select the curl statement generated as output of the previous step and execute it You should see output like : { &quot;type&quot;: &quot;http:\/\/proteanic.org\/api\/problems\/examples\/lazy-server-gremlins&quot;, &quot;title&quot;: &quot;The service is unavailable - lazy server gremlins.&quot;, &quot;detail&quot;: &quot;You have asked for something, but the service is unavailable, the server gremlins cannot be bothered to do any work right now.&quot;, &quot;instance&quot;: &quot;http:\/\/host.port\/tutorial-3\/play&quot; } ","tags":"","loc":"tutorial.html#tut-part-5"},{"title":"Tutorial \/ Part 6 - simulation (responses)","text":" Part 6 - Simulation Simulating dynamic responses { :includes [&quot;defaults.edn&quot;] :title &quot;Tutorial 6&quot; &quot;tutorial-6&quot; { &quot;play\/${stateId}&quot; { :types { :StateId &quot;(cave|forest)&quot; } :get { :doc &quot;A single player REST adventure world&quot; :description &quot;A simple text adventure world for one player. Sample usage may be something like \/tutorial-6\/play\/cave, indicating the player is in a cave.&quot; :vars { &quot;stateId&quot; {:type :StateId :doc &quot;ID for the state of the game&quot;} } :rsp { :200 { :doc &quot;OK&quot; :body-example &quot;test-data\/content\/tutorial\/tutorial-3\/200-ref.json&quot; } :404 {:doc &quot;Not Found&quot;} } } } } } Now the sim extension. (refer 'protean.core.transformation.sim) (defn param2rsp [{:keys [route-params]} data-path] (if-let [rsp (rsp-body data-path (path-param route-params) &quot;.json&quot;)] (slurp rsp) {:status 404})) { &quot;tutorial-6&quot; { &quot;play\/${stateId}&quot; { :get [ (fn [] (param2rsp *request* &quot;public\/tutorial\/6&quot;)) ] } } } Explanation In the codex above we have converged on a slightly more realistic example. Our endpoint includes a path parameter, and we are now provisioning for cases where the resource requested does not exist. We have created a custom type for our path parameter, indicating that its value can be either 'cave' or 'forest'. In our sim extension we now look up a response body based on the value of the path parameter. We provide two nonsense responses in json files. Run it Run the simulation. copy tutorial-6.cod.edn and tutorial-6.sim.edn from public\/tutorial to your codex directory run protean-server run protean services run protean service-usage -n tutorial-6 select the curl statement generated as output of the previous step, ensure the path parameter is either cave or forest and execute it You should see output like : { &quot;description&quot;: &quot;You are in a cave, it is very dark&quot; } ","tags":"","loc":"tutorial.html#tut-part-6"},{"title":"Getting Started \/ Installing","text":" Installing Linux There is a tried and tested .deb for Debian\/Ubuntu flavours of Linux at : https:\/\/github.com\/passivsystems\/protean\/releases\/download\/0.9.0-pre.7\/protean_0.9.0_all.deb Mac OSX For OSX we have a brogrammer script, trust us, it is safe :-) This will install to ~\/bin and in a very impolite way spew a couple of files out in there. In a terminal run bash &lt;(curl -fksSL https:\/\/raw.githubusercontent.com\/passivsystems\/protean\/develop\/install\/install.sh) ","tags":"","loc":"getting-started.html#installing"},{"title":"Getting Started \/ Starting","text":" Starting In a terminal run protean-server. This will start the sim server. You will see some output when you run this startup command, including information on where service definitions live. ","tags":"","loc":"getting-started.html#starting"},{"title":"Getting Started \/ Simulation","text":" Simulation Protean ships with a sample 'petstore' service for you to experiment with. See sample-petstore.cod.edn in the 'codex' directory which is listed in the output when you run the startup command. You can use a command line interface CLI to play with Protean. In a terminal run protean to get some help with things. Run protean services to list all services. Run protean service-usage -n petstore to get a list of curl commands you can hit the service with. Add your own service to Protean by running protean add-services -f myservice.cod.edn. ","tags":"","loc":"getting-started.html#simulation"},{"title":"Home \/ Overview","text":" Overview Take control of your RESTful API's. Encode then, document them, simulate them and figure out how failure affects your architecture. No invasive changes to your code base. ","tags":"","loc":"index.html#overview"},{"title":"Home \/ Features","text":" Features Encode API's Document API's Simulate API's Hotswap API behaviour on the fly over the network Auto generate curl commands to test your API's ","tags":"","loc":"index.html#features"}]};var tipuedrop=tipuesearch;var tipuesearch_stop_words = ["and", "be", "by", "do", "for", "he", "how", "if", "is", "it", "my", "not", "of", "or", "the", "to", "up", "what", "when"];var tipuesearch_replace = {"words": []};var tipuesearch_stem = {"words": []};