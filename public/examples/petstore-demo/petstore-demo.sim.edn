(ns protean.petstore.demo
  (:require [clj-http.client :as client]
            [taoensso.timbre :as timbre]
            [taoensso.timbre.appenders.core :as appenders]
            [petstorelib :as lib]
            [protean.api.transformation.coerce :as coerce]
            [protean.api.transformation.sim :refer :all]))

(def log-cfg {:level :debug
              :appenders {:spit (appenders/spit-appender {:fname "petstore.log"})}})

(defn petstore-log
  ([level a]        (timbre/log* log-cfg level a)) ;; first one may be exception
  ([level a & args] (timbre/log* log-cfg level a (clojure.string/join " " args))))

(def counter (atom 0))

{
  "petstore-demo" {
    :sim-cfg {:validating false} ; true by default
    "api/pet" {
      ;; No validation
      :put #(respond % 200)

      ;; Change default validation error response to 405 and adds errors to body
      :post #(if-let [errors (validate %)]
              (respond % 405 errors)
              (respond % 201))
    }

    "api/pet/${petId}" {
      ; load shared petstorelib.clj file
      ; wait 2 seconds before responding
      :get #(do (log/info lib/hello-world 1) ;; To protean.log
                (petstore-log :info lib/hello-world 2) ;; To petstore.log
                (Thread/sleep 2000)
                (respond % 200))

      ; select a random codex error response
      :delete #(rand-nth (error-responses %))

      ; 50% chance of a random codex error response
      :patch #(if (< (rand) 0.5)
               (first (success-responses %))
               (rand-nth (error-responses %)))

      ;; Sends synchronous and asynchronous requests to another API and logs the response
      :post #(if-let [errors (validate %)]
              (respond % 405 errors)
              (let [url "http://localhost:3000/protean-utils/echo"
                    fps (:form-params %)
                    handle (fn [res] (log/info [(str "Response from " url) res]))]
                (handle (client/post url {:form-params fps :content-type :json :throw-exceptions false}))
                (in 3000 (handle (client/post url {:form-params fps :content-type :json :throw-exceptions false})))
                (respond % 200 (slurp (find-path % "public/data/content/doc/responses/simple/200-ref.json")))))
    }

    "api/uploadImage" {
      ; alternative to error with probability - every nth access gives error based on server state
      :post #(if (= 0 (mod (swap! counter inc) 3))
              (rand-nth (error-responses %))
              (first (success-responses %)))
    }
  }
}
